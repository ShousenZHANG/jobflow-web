import { promises as fs } from "node:fs";
import path from "node:path";

const ROOT = process.cwd();
const README_PATH = path.join(ROOT, "README.md");
const PRISMA_SCHEMA_PATH = path.join(ROOT, "prisma", "schema.prisma");

const AUTO_BLOCK_START = "<!-- AUTO_METRICS_BADGES_START -->";
const AUTO_BLOCK_END = "<!-- AUTO_METRICS_BADGES_END -->";

const IGNORE_DIRS = new Set([".git", ".next", "node_modules"]);
const HANDLER_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];

function toPosix(value) {
  return value.replaceAll("\\", "/");
}

async function walkFiles(dir, rel = "") {
  const current = path.join(dir, rel);
  const entries = await fs.readdir(current, { withFileTypes: true });
  const out = [];

  for (const entry of entries) {
    const relPath = rel ? path.join(rel, entry.name) : entry.name;
    if (entry.isDirectory()) {
      if (IGNORE_DIRS.has(entry.name)) continue;
      out.push(...(await walkFiles(dir, relPath)));
      continue;
    }
    if (entry.isFile()) out.push(toPosix(relPath));
  }

  return out;
}

async function countPrismaModels() {
  try {
    const schema = await fs.readFile(PRISMA_SCHEMA_PATH, "utf8");
    return [...schema.matchAll(/^\s*model\s+[A-Za-z_][A-Za-z0-9_]*\s*\{/gm)].length;
  } catch {
    return 0;
  }
}

async function countApiHandlers(files) {
  let count = 0;
  const routeFiles = files.filter(
    (file) => file.startsWith("app/api/") && file.endsWith("/route.ts"),
  );
  const pattern = new RegExp(
    `\\bexport\\s+(?:async\\s+)?function\\s+(${HANDLER_METHODS.join("|")})\\b`,
    "g",
  );

  for (const rel of routeFiles) {
    const content = await fs.readFile(path.join(ROOT, rel), "utf8");
    count += [...content.matchAll(pattern)].length;
  }
  return count;
}

function metricBadge(label, value, color) {
  const encodedLabel = encodeURIComponent(label.replaceAll(" ", "_"));
  const encodedValue = encodeURIComponent(String(value));
  return `![${label}](https://img.shields.io/badge/${encodedLabel}-${encodedValue}-${color})`;
}

function buildAutoBlock(metrics) {
  const lines = [
    AUTO_BLOCK_START,
    metricBadge("API Routes", metrics.apiRoutes, "0ea5e9"),
    metricBadge("API Handlers", metrics.apiHandlers, "0284c7"),
    metricBadge("Test Files", metrics.testFiles, "65a30d"),
    metricBadge("Prisma Models", metrics.prismaModels, "7c3aed"),
    metricBadge("Server Modules", metrics.serverModules, "334155"),
    metricBadge("UI Pages", metrics.uiPages, "0f766e"),
    "<!-- Generated by: npm run readme:metrics -->",
    AUTO_BLOCK_END,
  ];
  return lines.join("\n");
}

function updateReadmeBlock(readmeContent, block) {
  const escapedStart = AUTO_BLOCK_START.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const escapedEnd = AUTO_BLOCK_END.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const blockPattern = new RegExp(`${escapedStart}[\\s\\S]*?${escapedEnd}`, "m");

  if (blockPattern.test(readmeContent)) {
    return readmeContent.replace(blockPattern, block);
  }

  const anchor = "![License](https://img.shields.io/badge/License-Apache--2.0-blue)";
  const anchorIndex = readmeContent.indexOf(anchor);
  if (anchorIndex === -1) {
    return `${block}\n\n${readmeContent}`;
  }

  const insertAt = anchorIndex + anchor.length;
  return `${readmeContent.slice(0, insertAt)}\n${block}${readmeContent.slice(insertAt)}`;
}

async function main() {
  const files = await walkFiles(ROOT);
  const metrics = {
    apiRoutes: files.filter((file) => file.startsWith("app/api/") && file.endsWith("/route.ts"))
      .length,
    apiHandlers: await countApiHandlers(files),
    testFiles: files.filter((file) => /\.(test|spec)\.(ts|tsx|js|jsx)$/.test(file)).length,
    prismaModels: await countPrismaModels(),
    serverModules: files.filter(
      (file) =>
        file.startsWith("lib/server/") &&
        file.endsWith(".ts") &&
        !file.endsWith(".test.ts") &&
        !file.endsWith(".test.tsx"),
    ).length,
    uiPages: files.filter((file) => file.startsWith("app/") && file.endsWith("/page.tsx")).length,
  };

  const readme = await fs.readFile(README_PATH, "utf8");
  const nextReadme = updateReadmeBlock(readme, buildAutoBlock(metrics));
  await fs.writeFile(README_PATH, nextReadme, "utf8");

  console.log("README metrics updated:", metrics);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
